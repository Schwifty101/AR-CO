/**
 * Consultations Service
 *
 * Manages consultation booking CRUD, status tracking, and Cal.com integration:
 * - Booking creation (guest intake form)
 * - Status checking (guest tracking by reference number)
 * - Booking listing, detail view, and cancellation (staff)
 * - Cal.com webhook handling for appointment scheduling
 *
 * Shared types (ConsultationRow, mapConsultationRow, CONSULTATION_FEE_PKR) are
 * defined in {@link ./consultations.types consultations.types.ts}.
 *
 * @module ConsultationsModule
 *
 * @example
 * ```typescript
 * const booking = await consultationsService.createBooking({
 *   fullName: 'Jane Doe',
 *   email: 'jane@example.com',
 *   phoneNumber: '+923001234567',
 *   practiceArea: 'Corporate Law',
 *   urgency: ConsultationUrgency.HIGH,
 *   issueSummary: 'Need legal advice on partnership agreement...',
 * });
 * // Returns booking with reference number (e.g., 'CON-2026-0001')
 * ```
 */

import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
  ConflictException,
} from '@nestjs/common';
import { SupabaseService } from '../database/supabase.service';
import { SafepayService } from '../payments/safepay.service';
import type { DbResult, DbListResult } from '../database/db-result.types';
import {
  validateSortColumn,
  sanitizePostgrestFilter,
} from '../common/utils/query-helpers';
import type {
  CreateConsultationData,
  ConsultationStatusCheckData,
  ConsultationResponse,
  ConsultationStatusResponse,
  PaginatedConsultationsResponse,
  ConsultationFilters,
  PaginationParams,
  ConsultationPaymentInitResponse,
  ConfirmConsultationPaymentData,
} from '@repo/shared';
import {
  ConsultationBookingStatus,
  ConsultationPaymentStatus,
} from '@repo/shared';
import {
  ConsultationRow,
  CONSULTATION_FEE_PKR,
  mapConsultationRow,
  type CalcomWebhookPayload,
} from './consultations.types';

/**
 * Allowed columns for sorting consultation list queries.
 * Prevents SQL injection by whitelisting sortable columns.
 */
const ALLOWED_SORT_COLUMNS = [
  'created_at',
  'updated_at',
  'reference_number',
  'booking_status',
  'payment_status',
] as const;

@Injectable()
export class ConsultationsService {
  private readonly logger = new Logger(ConsultationsService.name);

  constructor(
    private readonly supabaseService: SupabaseService,
    private readonly safepayService: SafepayService,
  ) {}

  /**
   * Creates a new consultation booking (Step 1: Guest intake form)
   *
   * Stores guest info. Reference number is auto-generated by database trigger.
   * Initial state: booking_status = 'pending_payment', payment_status = 'pending'.
   *
   * @param data - Guest-provided consultation details
   * @returns Created booking with reference number
   * @throws {BadRequestException} If database insert fails
   *
   * @example
   * ```typescript
   * const booking = await consultationsService.createBooking({
   *   fullName: 'Jane Doe',
   *   email: 'jane@example.com',
   *   phoneNumber: '+923001234567',
   *   practiceArea: 'Corporate Law',
   *   urgency: ConsultationUrgency.HIGH,
   *   issueSummary: 'Need legal advice on partnership agreement...',
   * });
   * // booking.referenceNumber → 'CON-2026-0042'
   * ```
   */
  async createBooking(
    data: CreateConsultationData,
  ): Promise<ConsultationResponse> {
    this.logger.log(`Creating consultation booking for: ${data.email}`);

    const adminClient = this.supabaseService.getAdminClient();

    // reference_number is generated atomically by the DB trigger (set_consultation_reference)
    const { data: booking, error } = (await adminClient
      .from('consultation_bookings')
      .insert({
        full_name: data.fullName,
        email: data.email,
        phone_number: data.phoneNumber,
        practice_area: data.practiceArea,
        urgency: data.urgency,
        issue_summary: data.issueSummary,
        relevant_dates: data.relevantDates ?? null,
        opposing_party: data.opposingParty ?? null,
        additional_notes: data.additionalNotes ?? null,
        consultation_fee: CONSULTATION_FEE_PKR,
        payment_status: ConsultationPaymentStatus.PENDING,
        booking_status: ConsultationBookingStatus.PENDING_PAYMENT,
      })
      .select()
      .single()) as DbResult<ConsultationRow>;

    if (error || !booking) {
      this.logger.error('Failed to create consultation booking', error);
      throw new BadRequestException('Failed to create consultation booking');
    }

    this.logger.log(
      `Booking created: ${booking.reference_number} (ID: ${booking.id})`,
    );
    return mapConsultationRow(booking);
  }

  /**
   * Initiates Safepay payment session for a consultation booking (Step 2: Payment)
   *
   * Creates a Safepay checkout session and returns the URL for guest payment.
   * Stores the tracker token in the database for later verification.
   *
   * @param bookingId - UUID of the consultation booking
   * @returns Safepay checkout URL, amount, currency, and order ID
   * @throws {NotFoundException} If booking not found
   * @throws {BadRequestException} If payment already completed
   *
   * @example
   * ```typescript
   * const payment = await consultationsService.initiatePayment('booking-uuid');
   * // payment.checkoutUrl → 'https://sandbox.api.getsafepay.com/checkout/...'
   * // payment.amount → 50000000 (500 PKR in paisa)
   * // payment.currency → 'PKR'
   * // payment.orderId → 'CON-2026-0042'
   * ```
   */
  async initiatePayment(
    bookingId: string,
  ): Promise<ConsultationPaymentInitResponse> {
    this.logger.log(`Initiating payment for booking: ${bookingId}`);

    const adminClient = this.supabaseService.getAdminClient();

    // Fetch booking
    const { data: booking, error } = (await adminClient
      .from('consultation_bookings')
      .select('*')
      .eq('id', bookingId)
      .single()) as DbResult<ConsultationRow>;

    if (error || !booking) {
      throw new NotFoundException('Booking not found');
    }

    // Check if already paid
    if (
      (booking.payment_status as unknown as ConsultationPaymentStatus) ===
      ConsultationPaymentStatus.PAID
    ) {
      throw new BadRequestException('Payment already completed');
    }

    // Calculate amount in paisa (Safepay requires smallest currency unit)
    const amountInPaisa = CONSULTATION_FEE_PKR * 100;

    // Step 1: Create Safepay payment session (tracker)
    const session = await this.safepayService.createPaymentSession({
      amount: amountInPaisa,
      currency: 'PKR',
      orderId: booking.reference_number,
    });

    // Step 2: Generate checkout URL with TBT auth token
    const checkoutUrl = await this.safepayService.generateCheckoutUrl(
      session.trackerToken,
    );

    // Store tracker token in database
    const { error: updateError } = await adminClient
      .from('consultation_bookings')
      .update({ safepay_tracker_token: session.trackerToken })
      .eq('id', bookingId);

    if (updateError) {
      this.logger.error('Failed to store tracker token', updateError);
      throw new BadRequestException('Failed to initiate payment session');
    }

    this.logger.log(
      `Payment session created for ${booking.reference_number}: ${session.trackerToken}`,
    );

    return {
      checkoutUrl,
      amount: session.amount,
      currency: session.currency,
      orderId: session.orderId,
    };
  }

  /**
   * Confirms Safepay payment and updates booking status (Step 3: Verify Payment)
   *
   * Verifies payment via Safepay Reporter API and updates booking to 'payment_confirmed' status.
   * This gating step must complete before guest can access Cal.com scheduling (Step 4).
   *
   * Idempotent: Returns existing booking if already paid (safe to call multiple times).
   *
   * @param bookingId - UUID of the consultation booking
   * @param dto - Contains trackerToken from payment redirect callback
   * @returns Updated booking with payment_confirmed status
   * @throws {NotFoundException} If booking not found
   * @throws {BadRequestException} If payment verification fails
   *
   * @example
   * ```typescript
   * const confirmed = await consultationsService.confirmPayment('booking-uuid', {
   *   trackerToken: 'track_xxx',
   * });
   * // confirmed.paymentStatus → 'paid'
   * // confirmed.bookingStatus → 'payment_confirmed'
   * // confirmed.safepayTransactionRef → 'ch_xxx' (charge token)
   * ```
   */
  async confirmPayment(
    bookingId: string,
    dto: ConfirmConsultationPaymentData,
  ): Promise<ConsultationResponse> {
    this.logger.log(`Confirming payment for booking: ${bookingId}`);

    const adminClient = this.supabaseService.getAdminClient();

    // Fetch booking
    const { data: booking, error } = (await adminClient
      .from('consultation_bookings')
      .select('*')
      .eq('id', bookingId)
      .single()) as DbResult<ConsultationRow>;

    if (error || !booking) {
      throw new NotFoundException('Booking not found');
    }

    // Idempotency: if already paid, return existing booking
    if (
      (booking.payment_status as unknown as ConsultationPaymentStatus) ===
      ConsultationPaymentStatus.PAID
    ) {
      this.logger.log(
        `Booking ${booking.reference_number} already paid, returning existing data`,
      );
      return mapConsultationRow(booking);
    }

    // Verify payment via Safepay Reporter API
    const verification = await this.safepayService.verifyPayment(
      dto.trackerToken,
    );

    if (!verification.isPaid) {
      throw new BadRequestException(
        `Payment not confirmed. Status: ${verification.state}`,
      );
    }

    // Update booking with payment confirmation
    const { data: updated, error: updateError } = (await adminClient
      .from('consultation_bookings')
      .update({
        payment_status: ConsultationPaymentStatus.PAID,
        booking_status: ConsultationBookingStatus.PAYMENT_CONFIRMED,
        safepay_transaction_ref: verification.reference,
        safepay_tracker_token: dto.trackerToken,
      })
      .eq('id', bookingId)
      .select()
      .single()) as DbResult<ConsultationRow>;

    if (updateError || !updated) {
      this.logger.error('Failed to update booking after payment', updateError);
      throw new BadRequestException('Failed to confirm payment');
    }

    this.logger.log(
      `Payment confirmed for ${updated.reference_number}: ${verification.reference}`,
    );

    return mapConsultationRow(updated);
  }

  /**
   * Retrieves booking status for guest tracking (minimal info)
   *
   * Guest-safe endpoint that returns only essential status info.
   * Requires both reference number and email to prevent unauthorized lookups.
   *
   * @param query - Reference number and email for verification
   * @returns Guest-safe status response
   * @throws {NotFoundException} If booking not found or email mismatch
   *
   * @example
   * ```typescript
   * const status = await consultationsService.getBookingStatus({
   *   referenceNumber: 'CON-2026-0042',
   *   email: 'jane@example.com',
   * });
   * // status.bookingStatus → 'booked'
   * // status.meetingLink → 'https://meet.google.com/...'
   * ```
   */
  async getBookingStatus(
    query: ConsultationStatusCheckData,
  ): Promise<ConsultationStatusResponse> {
    this.logger.log(`Checking status for: ${query.referenceNumber}`);

    const adminClient = this.supabaseService.getAdminClient();

    const { data: booking, error } = (await adminClient
      .from('consultation_bookings')
      .select(
        'reference_number, booking_status, payment_status, booking_date, booking_time, meeting_link, created_at',
      )
      .eq('reference_number', query.referenceNumber)
      .eq('email', query.email)
      .single()) as DbResult<{
      reference_number: string;
      booking_status: string;
      payment_status: string;
      booking_date: string | null;
      booking_time: string | null;
      meeting_link: string | null;
      created_at: string;
    }>;

    if (error || !booking) {
      throw new NotFoundException('Booking not found or email mismatch');
    }

    return {
      referenceNumber: booking.reference_number,
      bookingStatus:
        booking.booking_status as unknown as ConsultationStatusResponse['bookingStatus'],
      paymentStatus:
        booking.payment_status as unknown as ConsultationStatusResponse['paymentStatus'],
      bookingDate: booking.booking_date,
      bookingTime: booking.booking_time,
      meetingLink: booking.meeting_link,
      createdAt: booking.created_at,
    };
  }

  /**
   * Get consultations for the authenticated user by email
   *
   * @param email - Authenticated user's email
   * @param pagination - Pagination parameters
   * @returns Paginated consultations matching the user's email
   *
   * @example
   * ```typescript
   * const myConsultations = await consultationsService.getMyConsultations(
   *   'jane@example.com',
   *   { page: 1, limit: 10 },
   * );
   * ```
   */
  async getMyConsultations(
    email: string,
    pagination: PaginationParams,
  ): Promise<PaginatedConsultationsResponse> {
    const adminClient = this.supabaseService.getAdminClient();

    const page = pagination.page ?? 1;
    const limit = pagination.limit ?? 20;
    const offset = (page - 1) * limit;

    // Count query
    const { count, error: countError } = await adminClient
      .from('consultation_bookings')
      .select('*', { count: 'exact', head: true })
      .ilike('email', email);

    if (countError) {
      this.logger.error(
        `Failed to count my consultations: ${countError.message}`,
      );
      throw new BadRequestException('Failed to fetch consultations');
    }

    const total = count ?? 0;

    // Data query
    const { data, error } = await adminClient
      .from('consultation_bookings')
      .select('*')
      .ilike('email', email)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) {
      this.logger.error(`Failed to fetch my consultations: ${error.message}`);
      throw new BadRequestException('Failed to fetch consultations');
    }

    return {
      data: (data as ConsultationRow[]).map(mapConsultationRow),
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * Lists all consultation bookings (staff view)
   *
   * Supports pagination, filtering by booking status, payment status, and practice area.
   * Also supports full-text search across guest name and email.
   *
   * @param pagination - Page, limit, sort, order
   * @param filters - Optional filters (bookingStatus, paymentStatus, practiceArea)
   * @param search - Optional search query (searches full_name and email)
   * @returns Paginated consultation bookings
   *
   * @example
   * ```typescript
   * const results = await consultationsService.getBookings(
   *   { page: 1, limit: 20, sort: 'created_at', order: 'desc' },
   *   { bookingStatus: ConsultationBookingStatus.BOOKED },
   *   'jane',
   * );
   * // results.data → [...bookings]
   * // results.meta.total → 42
   * ```
   */
  async getBookings(
    pagination: PaginationParams,
    filters?: ConsultationFilters,
    search?: string,
  ): Promise<PaginatedConsultationsResponse> {
    this.logger.log(
      `Fetching consultations: page=${pagination.page} limit=${pagination.limit}`,
    );

    const adminClient = this.supabaseService.getAdminClient();

    // Build query
    let query = adminClient.from('consultation_bookings').select('*', {
      count: 'exact',
    });

    // Apply filters
    if (filters?.bookingStatus) {
      query = query.eq('booking_status', filters.bookingStatus);
    }
    if (filters?.paymentStatus) {
      query = query.eq('payment_status', filters.paymentStatus);
    }
    if (filters?.practiceArea) {
      query = query.eq('practice_area', filters.practiceArea);
    }

    // Apply search
    if (search && search.trim()) {
      const safe = sanitizePostgrestFilter(search.trim());
      query = query.or(`full_name.ilike.%${safe}%,email.ilike.%${safe}%`);
    }

    // Apply sorting
    const sortCol = validateSortColumn(
      pagination.sort || 'created_at',
      ALLOWED_SORT_COLUMNS,
    );
    const order =
      pagination.order === 'asc' ? { ascending: true } : { ascending: false };
    query = query.order(sortCol, order);

    // Apply pagination
    const offset = (pagination.page - 1) * pagination.limit;
    query = query.range(offset, offset + pagination.limit - 1);

    const { data, error, count } =
      (await query) as DbListResult<ConsultationRow>;

    if (error) {
      this.logger.error('Failed to fetch consultations', error);
      throw new BadRequestException(
        `Failed to fetch consultations: ${error.message}`,
      );
    }

    const total = count ?? 0;
    const totalPages = Math.ceil(total / pagination.limit);

    return {
      data: (data ?? []).map((row) => mapConsultationRow(row)),
      meta: {
        page: pagination.page,
        limit: pagination.limit,
        total,
        totalPages,
      },
    };
  }

  /**
   * Retrieves a single consultation booking by ID (staff view)
   *
   * @param id - UUID of the consultation booking
   * @returns Full booking details
   * @throws {NotFoundException} If booking not found
   *
   * @example
   * ```typescript
   * const booking = await consultationsService.getBookingById('booking-uuid');
   * ```
   */
  async getBookingById(id: string): Promise<ConsultationResponse> {
    this.logger.log(`Fetching booking: ${id}`);

    const adminClient = this.supabaseService.getAdminClient();

    const { data: booking, error } = (await adminClient
      .from('consultation_bookings')
      .select('*')
      .eq('id', id)
      .single()) as DbResult<ConsultationRow>;

    if (error || !booking) {
      throw new NotFoundException('Booking not found');
    }

    return mapConsultationRow(booking);
  }

  /**
   * Cancels a consultation booking (staff action)
   *
   * Sets booking_status to 'cancelled'. Does not process refunds automatically.
   *
   * @param id - UUID of the consultation booking
   * @returns Updated booking with cancelled status
   * @throws {NotFoundException} If booking not found
   * @throws {ConflictException} If booking already completed/cancelled
   *
   * @example
   * ```typescript
   * const cancelled = await consultationsService.cancelBooking('booking-uuid');
   * // cancelled.bookingStatus → 'cancelled'
   * ```
   */
  async cancelBooking(id: string): Promise<ConsultationResponse> {
    this.logger.log(`Cancelling booking: ${id}`);

    const adminClient = this.supabaseService.getAdminClient();

    const { data: booking, error: fetchError } = (await adminClient
      .from('consultation_bookings')
      .select('booking_status')
      .eq('id', id)
      .single()) as DbResult<{ booking_status: string }>;

    if (fetchError || !booking) {
      throw new NotFoundException('Booking not found');
    }

    if (
      (booking.booking_status as ConsultationBookingStatus) ===
        ConsultationBookingStatus.COMPLETED ||
      (booking.booking_status as ConsultationBookingStatus) ===
        ConsultationBookingStatus.CANCELLED
    ) {
      throw new ConflictException(
        `Cannot cancel booking with status: ${booking.booking_status}`,
      );
    }

    const { data: updated, error: updateError } = (await adminClient
      .from('consultation_bookings')
      .update({ booking_status: ConsultationBookingStatus.CANCELLED })
      .eq('id', id)
      .select()
      .single()) as DbResult<ConsultationRow>;

    if (updateError || !updated) {
      this.logger.error('Failed to cancel booking', updateError);
      throw new BadRequestException(
        `Failed to cancel booking: ${updateError?.message ?? 'Unknown error'}`,
      );
    }

    this.logger.log(`Booking ${id} cancelled successfully`);
    return mapConsultationRow(updated);
  }

  /**
   * Handles Cal.com webhook for appointment scheduling
   *
   * Triggered when guest books an appointment via embedded Cal.com.
   * Matches booking by:
   * 1. metadata.referenceNumber (if present)
   * 2. Fallback: attendee email + payment_confirmed status + no existing calcom_booking_uid
   *
   * Idempotent: skips update if calcom_booking_uid already linked.
   *
   * @param payload - Cal.com webhook payload (BOOKING_CREATED event)
   * @returns Updated booking or null if not found
   *
   * @example
   * ```typescript
   * const updated = await consultationsService.handleCalcomWebhook({
   *   triggerEvent: 'BOOKING_CREATED',
   *   payload: {
   *     uid: 'calcom-uid',
   *     id: 12345,
   *     startTime: '2026-03-15T10:00:00Z',
   *     metadata: { referenceNumber: 'CON-2026-0042' },
   *     responses: { email: { value: 'jane@example.com' } },
   *   },
   * });
   * ```
   */
  async handleCalcomWebhook(
    payload: CalcomWebhookPayload,
  ): Promise<ConsultationResponse | null> {
    this.logger.log(
      `Handling Cal.com webhook: ${payload.triggerEvent ?? 'unknown event'}`,
    );

    if (payload.triggerEvent !== 'BOOKING_CREATED') {
      this.logger.log('Ignoring non-BOOKING_CREATED event');
      return null;
    }

    const bookingData = payload.payload;
    const calcomUid = bookingData.uid;
    const calcomId = bookingData.id;
    const startTime = bookingData.startTime;
    const metadata = bookingData.metadata;

    const adminClient = this.supabaseService.getAdminClient();

    // Strategy 1: Match by metadata.referenceNumber
    const referenceNumber = metadata?.referenceNumber as string | undefined;
    let booking: ConsultationRow | null = null;

    if (referenceNumber) {
      this.logger.log(
        `Attempting match by referenceNumber: ${referenceNumber}`,
      );
      const { data } = (await adminClient
        .from('consultation_bookings')
        .select('*')
        .eq('reference_number', referenceNumber)
        .maybeSingle()) as DbResult<ConsultationRow>;
      booking = data;
    }

    // Strategy 2: Fallback - match by attendee email + payment_confirmed + no calcom_booking_uid
    if (!booking) {
      const attendeeEmail = bookingData.responses?.email?.value;

      if (attendeeEmail) {
        this.logger.log(`Attempting match by attendee email: ${attendeeEmail}`);
        const { data } = (await adminClient
          .from('consultation_bookings')
          .select('*')
          .eq('email', attendeeEmail)
          .eq('booking_status', ConsultationBookingStatus.PAYMENT_CONFIRMED)
          .is('calcom_booking_uid', null)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle()) as DbResult<ConsultationRow>;
        booking = data;
      }
    }

    if (!booking) {
      this.logger.warn(
        `No matching booking found for Cal.com webhook: ${calcomUid}`,
      );
      return null;
    }

    // Idempotency: skip if already linked
    if (booking.calcom_booking_uid) {
      this.logger.log(
        `Booking ${booking.reference_number} already linked to Cal.com UID ${booking.calcom_booking_uid}`,
      );
      return mapConsultationRow(booking);
    }

    // Update booking with Cal.com details
    const bookingDateTime = new Date(startTime);
    const meetingUrl =
      (metadata?.videoCallUrl as string) ?? bookingData.meetingUrl ?? null;

    const { data: updated, error } = (await adminClient
      .from('consultation_bookings')
      .update({
        calcom_booking_uid: calcomUid,
        calcom_booking_id: calcomId,
        booking_date: bookingDateTime.toISOString().split('T')[0],
        booking_time: bookingDateTime.toISOString().split('T')[1].slice(0, 5),
        meeting_link: meetingUrl,
        booking_status: ConsultationBookingStatus.BOOKED,
      })
      .eq('id', booking.id)
      .select()
      .single()) as DbResult<ConsultationRow>;

    if (error || !updated) {
      this.logger.error('Failed to update booking with Cal.com data', error);
      throw new BadRequestException(
        'Failed to update booking with Cal.com data',
      );
    }

    this.logger.log(
      `Booking ${booking.reference_number} linked to Cal.com UID ${calcomUid}`,
    );

    return mapConsultationRow(updated);
  }
}
